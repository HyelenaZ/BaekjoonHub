# [Silver V] 숫자 카드 - 10815 

[문제 링크](https://www.acmicpc.net/problem/10815) 

### 성능 요약

메모리: 114204 KB, 시간: 368 ms

### 분류

이분 탐색, 자료 구조, 해시를 사용한 집합과 맵, 정렬

### 제출 일자

2025년 1월 10일 22:52:52

### 문제 설명

<p>숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.</p>

<p>셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다</p>

### 출력 

 <p>첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.</p>

-------------------------------------------
# Hyo's Memo 📚

## 📍 Set & HashSet 자료구조
> Python의 set과 Java의 HashSet을 활용한 효율적인 검색 구현

### 기본 구현 🛠
```python
# Python
cards = set()  # 집합으로 구현
```

```java
// Java
HashSet<Integer> cards = new HashSet<>();  // HashSet으로 구현
```

### 연산별 구현 방법 ⚡
#### Python 🐍
| 연산 | 구현 | 시간복잡도 |
|------|------|------------|
| 원소 추가 | `set.add(x)` | O(1) |
| 원소 검색 | `x in set` | O(1) |
| 집합 생성 | `set(iterable)` | O(n) |

#### Java ☕
| 연산 | 구현 | 시간복잡도 |
|------|------|------------|
| 원소 추가 | `hashSet.add(x)` | O(1) |
| 원소 검색 | `hashSet.contains(x)` | O(1) |
| 크기 확인 | `hashSet.size()` | O(1) |

### 입력 처리 최적화 💡
#### Python
```python
# set으로 직접 변환
cards = set(input().split())
```

#### Java
```java
// StringTokenizer 활용
StringTokenizer st = new StringTokenizer(br.readLine());
while(st.hasMoreTokens()) {
    cards.add(Integer.parseInt(st.nextToken()));
}
```

### 주의사항 ⚠️
#### Python
- ✅ 중복값 자동 제거
- ⚠️ 순서 보장 안됨
- 💡 해시 기반 검색

#### Java
- ✅ null 값 허용
- ⚠️ 순서 보장 안됨
- 💡 equals(), hashCode() 오버라이드 주의

## 📍 복잡도 분석
### 시간 복잡도 ⏱️
- **생성**: O(N)
- **검색**: O(1)
- **전체**: O(N + M)

### 공간 복잡도 💾
- **저장공간**: O(N)
- **결과저장**: O(M)

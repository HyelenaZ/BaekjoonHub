# [Bronze II] 수 정렬하기 - 2750 

[문제 링크](https://www.acmicpc.net/problem/2750) 

### 성능 요약
메모리: 32412 KB, 시간: 56 ms

### 분류
정렬, 구현

### 제출 일자
2025년 1월 14일 02:35:49

### 문제 설명
<p>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.</p>

### 입력 
 <p>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.</p>

### 출력 
 <p>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.</p>


<img width="783" alt="image" src="https://github.com/user-attachments/assets/60cfcd05-5d23-4f3a-ac0a-fbdc19245c0c" />

------------------------------------------------------------------------------------
Hyo's Memo
------------------------------------------------------------------------------------
🎯 BJ 2750: 수 정렬하기

💡 핵심 개념
- 기본 정렬 구현
- 리스트 컴프리헨션으로 입력 처리
- Python의 내장 메서드 활용
  > input(): N개의 수 입력
  
  > list comprehension: N번 반복 입력 처리

  > sort() : 오름차순 정렬
  
  > for 문: 순차 출력
 
⚡ 동작 과정 사용 메서드


⏱️ 시간 복잡도
- O(NlogN): Python 내장 sort() 사용

💫 공간 복잡도
- O(N): 입력값 저장 리스트 공간

⚡ 추후 리팩토링
: 정렬 알고리즘 활용해서 바꿔볼것
1. 버블 정렬 구현
   - 시간복잡도: O(N²)
   - 공간복잡도: O(1)
   - 장점: 구현 간단, 추가 메모리 불필요
   - 단점: 느린 속도
2. 선택 정렬 구현
   - 시간복잡도: O(N²)
   - 공간복잡도: O(1)
   - 장점: 데이터 이동 최소화
   - 단점: 느린 속도
3. 퀵 정렬 구현
   - 시간복잡도: 평균 O(NlogN), 최악 O(N²)
   - 공간복잡도: O(logN)
   - 장점: 평균적으로 매우 빠름
   - 단점: 최악의 경우 성능 저하
4. 병합 정렬 구현
   - 시간복잡도: O(NlogN)
   - 공간복잡도: O(N)
   - 장점: 안정적인 속도
   - 단점: 추가 메모리 필요
     
